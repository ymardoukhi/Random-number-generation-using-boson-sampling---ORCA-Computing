import json
import argparse
import numpy as np
from src.PostProcessing import HuffmanEncoding

def main():

    # parse the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('n', type=int, help='number of photos')
    parser.add_argument('m', type=int, help='number of modes')
    parser.add_argument('n_param', type=int, help='number of beam-spliters')
    parser.add_argument('v', type=int, help='version of the architecture')
    parser.add_argument('N', type=int, help='number of simulations (shots)')
    args = parser.parse_args()

    # set the data path to load the simulation results
    data_path = "data/n{}_m{}_nparam{}_v{}".format(args.n, args.m, args.n_param, args.v)

    # load the exact fock state distribution and the fock state
    # samples generated previously by a Boson sampler
    with open("{}/exact_result.json".format(data_path), "r") as f:
        fock_states_dist = json.load(f)
    fock_state_samples = np.load("{}/samples_N{}.npy".format(data_path, args.N))

    # construct the Huffman encoding given the 
    # exact fock states distrubition
    encoding = HuffmanEncoding(fock_states_dist)
    encoding.huffman_encoding()

    # create auxiliary dictionary that indicates 
    # whether a specific fock state has appeared 
    # odd or even number of times
    aux_dict = {str(tuple(fock_state)): 0 for fock_state in fock_state_samples}

    # get the binary strings using the Huffman 
    # encoding scheme and flip the binary bits
    # every second time
    output_strs = []
    for fock_state in fock_state_samples:
        key = str(tuple(fock_state))
        bin_enc = encoding.encoding[key][aux_dict[key]%2]
        aux_dict[key] = (aux_dict[key] + 1)%2
        output_strs.append(bin_enc)

    # store the binary strings generated by the 
    # Huffman encoding
    with open("{}/huffman_strs_N{}.json".format(data_path, args.N), "w") as f:
        json.dump(output_strs, f)

if __name__ == "__main__":
    main()
